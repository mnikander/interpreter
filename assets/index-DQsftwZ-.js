(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))t(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&t(s)}).observe(document,{childList:!0,subtree:!0});function i(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerPolicy&&(r.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?r.credentials="include":o.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function t(o){if(o.ep)return;o.ep=!0;const r=i(o);fetch(o.href,r)}})();const c={whitespace:function(e,n,i){return{kind:"Token",subkind:"Whitespace",id:e,offset:n,value:i}},open:function(e,n,i){return{kind:"Token",subkind:"Open      ",id:e,offset:n,value:"("}},close:function(e,n,i){return{kind:"Token",subkind:"Close     ",id:e,offset:n,value:")"}},boolean:function(e,n,i){return i==="false"||i==="False"?{kind:"Token",subkind:"Boolean   ",id:e,offset:n,value:!1}:{kind:"Token",subkind:"Boolean   ",id:e,offset:n,value:!0}},number:function(e,n,i){return{kind:"Token",subkind:"Number    ",id:e,offset:n,value:Number(i)}},string:function(e,n,i){return{kind:"Token",subkind:"String    ",id:e,offset:n,value:i}},identifier:function(e,n,i){return{kind:"Token",subkind:"Identifier",id:e,offset:n,value:i}}},u={whitespace:function(e){return e.kind==="Token"&&e.subkind==="Whitespace"},open:function(e){return e.kind==="Token"&&e.subkind==="Open      "},close:function(e){return e.kind==="Token"&&e.subkind==="Close     "},boolean:function(e){return e.kind==="Token"&&e.subkind==="Boolean   "},number:function(e){return e.kind==="Token"&&e.subkind==="Number    "},string:function(e){return e.kind==="Token"&&e.subkind==="String    "},identifier:function(e){return e.kind==="Token"&&e.subkind==="Identifier"}};function A(e,n,i){return{kind:"Error",subkind:e,token_id:i,message:n}}function H(e,n){return`${e.subkind} error: ${e.message} at token number ${e.token_id} '${n[e.token_id].value}'`}function l(e){return e.ok===!0}function m(e){return e.ok===!1}function g(e){return{ok:!0,value:e}}function w(e,n,i){return{ok:!1,error:A(e,n,i)}}const f={whitespace:{description:"one or more whitespace characters",regex:/^\s+/},open:{description:"(",regex:/\(/},close:{description:")",regex:/\)/},bool:{description:"a boolean",regex:/^(true|false)/},int:{description:"an integer",regex:/^[-+]?[0-9]+/},float:{description:"a float",regex:/^[-+]?((\d+\.\d*)|(\d*\.\d+))/},string:{description:"a string",regex:/^"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/},id_alphanum:{description:"an alphanumeric identifier",regex:/^[_a-zA-Z][_a-zA-Z0-9]*/},id_special:{description:"an operation identifier",regex:/^[.,:;!?<>\=\@\#\$\+\-\*\/\%\&\|\^\~]+/}};function R(e){let n={ok:!0,value:{kind:"State",index:0,line:e,tokens:[]}};for(;l(n);)if(n.value.line.length>0)n=W(n.value);else return g(n.value.tokens);return n}function W(e){let n={ok:!0,value:e};return n=a(f.whitespace,c.whitespace,e),l(n)||(n=a(f.open,c.open,e),l(n))||(n=a(f.close,c.close,e),l(n))||(n=a(f.bool,c.boolean,e),l(n))||(n=a(f.float,c.number,e),l(n))||(n=a(f.int,c.number,e),l(n))||(n=a(f.string,c.string,e),l(n))||(n=a(f.id_alphanum,c.identifier,e),l(n))||(n=a(f.id_special,c.identifier,e),l(n))?n:w("Lexing","invalid token, expected an atom",e.tokens.length)}function a(e,n,i){const t=e.regex.exec(i.line);if(t&&t.index===0){const o=t[0];return i.index+=o.length,i.line=i.line.slice(o.length),n!==void 0&&i.tokens.push(n(i.tokens.length,i.index,o)),g(i)}else return w("Lexing",`invalid token, expected ${e.description}`,i.tokens.length)}function q(e){return e.kind==="Nested_Boolean"}function z(e){return e.kind==="Nested_Number"}function D(e){return e.kind==="Nested_String"}function G(e){return e.kind==="Nested_Identifier"}function Z(e){return e.kind==="Nested_Binding"}function K(e){return e.kind==="Nested_Lambda"}function U(e){return e.kind==="Nested_Let"}function j(e){return e.kind==="Nested_If"}function J(e){return e.kind==="Nested_Call"}class Q{constructor(n){this.index=0,this.node_count=0,this.tokens=n}peek(){if(0<=this.index&&this.index<this.tokens.length)return this.tokens[this.index];throw Error(`Parser::peek() is out-of-bounds (token ${this.index} of ${this.tokens.length})`)}previous(){if(1<=this.index&&this.index<this.tokens.length+1)return this.tokens[this.index-1];throw Error(`Parser::previous() is out-of-bounds (token ${this.index} of ${this.tokens.length})`)}consume(){this.index++}emit(){const n=this.node_count;return this.node_count++,n}is_at_end(){return this.index===this.tokens.length}expr(){if(this.is_at_end())throw Error(`Parser::expr() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(this.skip_whitespace(),u.boolean(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,kind:"Nested_Boolean",value:this.previous().value};if(u.number(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,kind:"Nested_Number",value:this.previous().value};if(u.string(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,kind:"Nested_String",value:this.previous().value};if(u.identifier(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,kind:"Nested_Identifier",name:this.previous().value};if(u.open(this.peek())){this.consume(),this.skip_whitespace();const n=this.peek();return u.identifier(n)&&n.value==="lambda"?this.lambda():u.identifier(n)&&n.value==="let"?this.letbind():u.identifier(n)&&n.value==="if"?this.iff():this.call()}else throw u.close(this.peek())?Error(`Expected an expression but got ')' instead (token ${this.index} of ${this.tokens.length})`):Error(`Unknown token kind '${this.peek()}' (token ${this.index} of ${this.tokens.length})`)}lambda(){const n=this.emit(),i=this.peek();if(this.consume(),this.expect_whitespace(),u.identifier(this.peek())){const t=this.binding();this.expect_whitespace();const o=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:i.id-1,kind:"Nested_Lambda",binding:t,body:o}}else throw new Error(`Expected an 'lambda' to be followed by an identifier but got a ${this.peek().subkind} instead (token ${this.index} of ${this.tokens.length})`)}letbind(){const n=this.emit(),i=this.peek();if(this.consume(),this.expect_whitespace(),u.identifier(this.peek())){const t=this.binding();this.expect_whitespace();const o=this.expr();this.expect_whitespace();const r=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:i.id-1,kind:"Nested_Let",binding:t,value:o,body:r}}else throw new Error(`Expected an 'let' to be followed by an identifier but got a ${this.peek().subkind} instead (token ${this.index} of ${this.tokens.length})`)}iff(){const n=this.emit(),i=this.peek();this.consume(),this.expect_whitespace();const t=this.expr();this.expect_whitespace();const o=this.expr();this.expect_whitespace();const r=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:i.id-1,kind:"Nested_If",condition:t,if_true:o,if_false:r}}call(){const n=this.emit(),i=this.expr();this.expect_whitespace();const t=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:i.token-1,kind:"Nested_Call",fn:i,arg:t}}binding(){const n=this.emit(),i=this.peek();return this.consume(),{id:n,token:i.id,kind:"Nested_Binding",name:i.value}}skip_whitespace(){for(;!this.is_at_end()&&u.whitespace(this.peek());)this.consume()}expect_whitespace(){if(this.is_at_end())throw Error(`Parser::expect_whitespace() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(u.whitespace(this.peek()))this.consume();else throw new Error(`Expected a whitespace and another expression, but got a '${this.peek().subkind}' instead (token ${this.index} of ${this.tokens.length})`)}expect_closing(){if(this.is_at_end())throw Error(`Parser::expect_closing() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(u.close(this.peek()))this.consume();else throw new Error(`Expected ')' but got a '${this.peek().subkind}' instead (token ${this.index} of ${this.tokens.length})`)}}function V(e){if(m(e))throw Error("Lexing failed");{let n=new Q(e.value);n.skip_whitespace();const i=n.expr();if(n.skip_whitespace(),n.is_at_end())return{ast:i,node_count:n.node_count};throw Error(`Expected a single expression, failed to fully parse input (token ${n.index} of ${n.tokens.length})`)}}function _(e,n){return e.kind==="Flat_Literal"}function v(e,n){return e.kind==="Flat_Identifier"}function y(e,n){return e.kind==="Flat_Binding"}function $(e,n){return e.kind==="Flat_Reference"}function E(e,n){return e.kind==="Flat_Lambda"}function N(e,n){return e.kind==="Flat_Let"}function x(e,n){return e.kind==="Flat_If"}function L(e,n){return e.kind==="Flat_Call"}function X(e,n){return e.kind==="Flat_Builtin"}const B=["==","!=","<",">","<=",">=","+","-","*","/","%","~","&&","||","!"];function Y(e,n,i,t){if(ie(e))return ee(e,n,i,t);if(te(e))return ne(e,n,i,t);throw Error(`The evaluation of the built-in function '${e.name} has not been implemented.`)}function ee(e,n,i,t){if(t.length<1)throw Error(`Stack contains ${t.length} arguments, but expected 1 for the unary operation ${e.name}.`);const o=t.pop();if(F(e)){if(typeof o!="number")throw Error("Built-in negative operation only supports numbers");return-o}else if(O(e)){if(typeof o!="boolean")throw Error("Built-in logical not operation only supports booleans");return!o}else throw Error(`The evaluation of the unary built-in function '${e.name} has not been implemented.`)}function ne(e,n,i,t){if(t.length<2)throw Error(`Stack contains ${t.length} arguments, but expected 2 for the binary operation ${e.name}.`);const o=t.pop(),r=t.pop();if(o===void 0)throw Error(`First argument of ${e.name} is undefined`);if(r===void 0)throw Error(`Second argument of ${e.name} is undefined`);if(T(e))switch(e.name){case"==":return o==r;case"!=":return o!=r;default:throw Error(`Cannot evaluate binary operation '${e.name}' at token ${e.token}`)}else if(C(e)||I(e)){if(typeof o!="number"||typeof r!="number")throw Error("Built-in comparison/arithmetic operations only support numbers");switch(e.name){case"<":return o<r;case">":return o>r;case"<=":return o<=r;case">=":return o>=r;case"+":return o+r;case"-":return o-r;case"*":return o*r;case"/":return o/r;case"%":return o%r;default:throw Error(`Cannot evaluate binary operation '${e.name}' at token ${e.token}`)}}else if(S(e)){if(typeof o!="boolean"||typeof r!="boolean")throw Error("Built-in logical operations only support booleans");switch(e.name){case"&&":return o&&r;case"||":return o||r;default:throw Error(`Cannot evaluate binary operation '${e.name}' at token ${e.token}`)}}throw Error(`The evaluation of the binary built-in function '${e.name} has not been implemented.`)}function ie(e){return O(e)||F(e)}function te(e){return T(e)||C(e)||I(e)||S(e)}function T(e){return e.name==="=="||e.name==="!="}function C(e){return e.name==="<"||e.name===">"||e.name==="<="||e.name===">="}function I(e){return e.name==="+"||e.name==="-"||e.name==="*"||e.name==="/"||e.name==="%"}function F(e){return e.name==="~"}function S(e){return e.name==="&&"||e.name==="||"}function O(e){return e.name==="!"}function oe(){return{parent:void 0,bindings:new Map}}function b(e){return{parent:e,bindings:new Map}}function P(e,n){const i=n.bindings.get(e);if(i!==void 0)return i;if(n.parent!==void 0)return P(e,n.parent);throw new Error(`variable with id ${e} is undefined`)}function h(e,n,i,t){if(_(e))return e.value;if(v(e))throw Error(`Cannot evaluate unresolved reference to '${e.name}' at token ${e.token}`);if(y(e))return P(e.id,i);if(X(e))return Y(e,n,i,t);if($(e))return h(n[e.target.id],n,i,t);if(E(e)){let o=t.pop();if(o!==void 0){let r=b(i);return r.bindings.set(e.binding.id,o),h(n[e.body.id],n,r,t)}else throw new Error("No arguments to bind to variable")}else if(N(e)){let o=b(i);return o.bindings.set(e.binding.id,h(n[e.value.id],n,i,t)),h(n[e.body.id],n,o,t)}else if(x(e)){const o=h(n[e.condition.id],n,i,t);if(typeof o=="boolean")return h(n[o?e.if_true.id:e.if_false.id],n,i,t);throw new Error("Condition in 'if' expression did not evaluate to a boolean value")}else if(L(e)){const o=h(n[e.arg.id],n,i,t);return h(n[e.body.id],n,i,[...t,o])}else throw new Error("unhandled case in evaluation control flow")}function re(e,n){const i=Array(n);return d(e,i)}function d(e,n){if(K(e)){const i=e.id,t={id:e.binding.id},o={id:e.body.id};let r={id:i,token:e.token,kind:"Flat_Lambda",binding:t,body:o};n[i]=r,n=d(e.binding,n),n=d(e.body,n)}else if(U(e)){const i=e.id,t={id:e.binding.id},o={id:e.value.id},r={id:e.body.id};let s={id:i,token:e.token,kind:"Flat_Let",binding:t,value:o,body:r};n[i]=s,n=d(e.binding,n),n=d(e.value,n),n=d(e.body,n)}else if(j(e)){const i=e.id,t={id:e.condition.id},o={id:e.if_true.id},r={id:e.if_false.id};let s={id:i,token:e.token,kind:"Flat_If",condition:t,if_true:o,if_false:r};n[i]=s,n=d(e.condition,n),n=d(e.if_true,n),n=d(e.if_false,n)}else if(J(e)){const i=e.id,t={id:e.fn.id},o={id:e.arg.id};let r={id:i,token:e.token,kind:"Flat_Call",body:t,arg:o};n[i]=r,n=d(e.fn,n),n=d(e.arg,n)}else if(q(e)||z(e)||D(e)){const i=e.id;let t={id:i,token:e.token,kind:"Flat_Literal",value:e.value};n[i]=t}else if(G(e)){const i=e.id;let t={id:i,token:e.token,kind:"Flat_Identifier",name:e.name};n[i]=t}else if(Z(e)){const i=e.id;let t={id:i,token:e.token,kind:"Flat_Binding",name:e.name};n[i]=t}else throw Error(`Cannot convert nested node of kind '${e.kind}' to a corresponding kind of flat node.`);return n}function se(e){let n=e.map(t=>t),i=le();return k(n[0],n,i)}function k(e,n,i){if(_(e)||y(e)||$(e))return n;if(v(e)){const t=e.id,o=e.token,r=M(e.name,i);if(r==="builtin")if(B.includes(e.name)){const s={id:t,token:o,kind:"Flat_Builtin",name:e.name};n[t]=s}else throw new Error(`'${e.name}' is not a built-in function`);else{const s={id:t,token:o,kind:"Flat_Reference",target:{id:r}};n[t]=s}return n}else if(E(e)){const t=n[e.binding.id],o=n[e.body.id];let r=p(i);return r.bindings.set(t.name,t.id),n=k(o,n,r),n}else if(N(e)){const t=n[e.binding.id],o=n[e.value.id],r=n[e.body.id];let s=p(i);return s.bindings.set(t.name,t.id),n=k(o,n,i),n=k(r,n,s),n}else if(L(e)){const t=n[e.body.id],o=n[e.arg.id];return n=k(t,n,i),n=k(o,n,i),n}else if(x(e)){const t=n[e.condition.id],o=n[e.if_true.id],r=n[e.if_false.id];return n=k(t,n,i),n=k(o,n,i),n=k(r,n,i),n}else throw Error(`Name resolution not implemented for node ${e.id} of kind ${e.kind}`)}function M(e,n){if(ue(n)){const i=n.bindings.get(e);if(i!==void 0)return i;throw new Error(`variable with name ${e} is undefined`)}else if(de(n)){const i=n.bindings.get(e);return i!==void 0?i:M(e,n.parent)}else throw Error("Invalid kind of scope. Something is wrong with the name resolution implementation.")}function ue(e){return e.kind==="GlobalScope"}function de(e){return e.kind==="Scope"}function p(e){return{kind:"Scope",parent:e,bindings:new Map}}function le(){let e=new Map;for(let n of B)e.set(n,"builtin");return{kind:"GlobalScope",bindings:e}}function ce(e){const n=R(e);if(m(n))return H(n.error,[]);const i=V(n),t=re(i.ast,i.node_count),o=se(t);let r=oe();return h(o[0],o,r,[])}function fe(){const e=document.getElementById("input"),n=document.getElementById("output");n&&new MutationObserver(()=>{n.scrollTop=n.scrollHeight}).observe(n,{childList:!0});const i=e.value;try{const t=ce(i);n.textContent+=`> ${i}
${t}
`}catch(t){const o=t instanceof Error?t.message:String(t);n.textContent+=`> ${i}
${o}
`}}document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("help-btn"),n=document.getElementById("help-box");e==null||e.addEventListener("click",()=>{n&&e&&(n.style.display==="block"?(n.style.display="none",e.textContent="Help"):(n.style.display="block",e.textContent="Close Help"))});const i=document.getElementById("output");i&&(i.textContent=`



















Welcome! Try typing:

((+ 1) 2)

and press Enter. For more info, click on the help button in the top corner.

`);const t=document.getElementById("input");t==null||t.focus(),t==null||t.setSelectionRange(t.value.length,t.value.length),t==null||t.addEventListener("keydown",o=>{o.key==="Enter"&&(o.preventDefault(),fe())})});
