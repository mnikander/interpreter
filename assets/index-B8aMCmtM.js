(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))i(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const l of r.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&i(l)}).observe(document,{childList:!0,subtree:!0});function t(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerPolicy&&(r.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?r.credentials="include":o.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(o){if(o.ep)return;o.ep=!0;const r=t(o);fetch(o.href,r)}})();const F={WHITESPACE:/^\s+/,OPEN:/^\(/,CLOSE:/^\)/,BOOLEAN:/^(true|false)/,NUMBER:/^[-+]?(?:\d*\.\d+|\d+\.\d*|\d+)/,STRING:/^"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,IDENTIFIER:/^(?:([_a-zA-Z][_a-zA-Z0-9]*)|([.,:;!?<>\=\@\#\$\+\-\*\/\%\&\|\^\~]+))/};function R(e){let n={tag:"State",offset:0,line:e,tokens:[]};for(;n.offset<n.line.length;){const t=d(n,"BOOLEAN")??d(n,"NUMBER")??d(n,"STRING")??d(n,"IDENTIFIER")??d(n,"WHITESPACE")??d(n,"OPEN")??d(n,"CLOSE");if(t)t.lexeme==="BOOLEAN"?n=c(n,A(n,t)):t.lexeme==="NUMBER"?n=c(n,M(n,t)):t.lexeme==="STRING"?n=c(n,H(n,t)):t.lexeme==="IDENTIFIER"?n=c(n,D(n,t)):t.lexeme==="OPEN"?n=c(n,G(n)):t.lexeme==="CLOSE"?n=c(n,U(n)):t.lexeme==="WHITESPACE"&&(n=c(n,W(n,t))),n.offset+=t.word.length;else throw Error(`Could not lex '${n.line[n.offset]}'.`)}return n.tokens}function d(e,n){const t=e.line.slice(e.offset),i=F[n].exec(t);if(i)return{lexeme:n,word:i[0]}}function c(e,n){return e.tokens.push(n),e}function A(e,n){const t=n.word!=="false";return{tag:"Token",lexeme:"BOOLEAN",id:e.tokens.length,offset:e.offset,value:t}}function M(e,n){return{tag:"Token",lexeme:"NUMBER",id:e.tokens.length,offset:e.offset,value:Number(n.word)}}function H(e,n){return{tag:"Token",lexeme:"STRING",id:e.tokens.length,offset:e.offset,value:n.word}}function D(e,n){return{tag:"Token",lexeme:"IDENTIFIER",id:e.tokens.length,offset:e.offset,value:n.word}}function G(e,n){return{tag:"Token",lexeme:"OPEN",id:e.tokens.length,offset:e.offset,value:"("}}function U(e,n){return{tag:"Token",lexeme:"CLOSE",id:e.tokens.length,offset:e.offset,value:")"}}function W(e,n){return{tag:"Token",lexeme:"WHITESPACE",id:e.tokens.length,offset:e.offset,value:n.word}}function f(e){return e.tag==="Token"}function q(e){return f(e)&&e.lexeme==="BOOLEAN"}function z(e){return f(e)&&e.lexeme==="NUMBER"}function Z(e){return f(e)&&e.lexeme==="STRING"}function h(e){return f(e)&&e.lexeme==="IDENTIFIER"}function K(e){return f(e)&&e.lexeme==="OPEN"}function g(e){return f(e)&&e.lexeme==="CLOSE"}function m(e){return f(e)&&e.lexeme==="WHITESPACE"}function j(e){return e.tag==="Nested_Boolean"}function J(e){return e.tag==="Nested_Number"}function Q(e){return e.tag==="Nested_String"}function V(e){return e.tag==="Nested_Identifier"}function X(e){return e.tag==="Nested_Binding"}function Y(e){return e.tag==="Nested_Lambda"}function ee(e){return e.tag==="Nested_Let"}function ne(e){return e.tag==="Nested_If"}function te(e){return e.tag==="Nested_Call"}class ie{constructor(n){this.index=0,this.node_count=0,this.tokens=n}peek(){if(0<=this.index&&this.index<this.tokens.length)return this.tokens[this.index];throw Error(`Parser::peek() is out-of-bounds (token ${this.index} of ${this.tokens.length})`)}previous(){if(1<=this.index&&this.index<this.tokens.length+1)return this.tokens[this.index-1];throw Error(`Parser::previous() is out-of-bounds (token ${this.index} of ${this.tokens.length})`)}consume(){this.index++}emit(){const n=this.node_count;return this.node_count++,n}is_at_end(){return this.index===this.tokens.length}expr(){if(this.is_at_end())throw Error(`Parser::expr() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(this.skip_whitespace(),q(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_Boolean",value:this.previous().value};if(z(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_Number",value:this.previous().value};if(Z(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_String",value:this.previous().value};if(h(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_Identifier",name:this.previous().value};if(K(this.peek())){this.consume(),this.skip_whitespace();const n=this.peek();return h(n)&&n.value==="lambda"?this.lambda():h(n)&&n.value==="let"?this.letbind():h(n)&&n.value==="if"?this.iff():this.call()}else throw g(this.peek())?Error(`Expected an expression but got ')' instead (token ${this.index} of ${this.tokens.length})`):Error(`Unknown token tag '${this.peek()}' (token ${this.index} of ${this.tokens.length})`)}lambda(){const n=this.emit(),t=this.peek();if(this.consume(),this.expect_whitespace(),h(this.peek())){const i=this.binding();this.expect_whitespace();const o=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:t.id-1,tag:"Nested_Lambda",binding:i,body:o}}else throw new Error(`Expected an 'lambda' to be followed by an identifier but got a ${this.peek().lexeme} instead (token ${this.index} of ${this.tokens.length})`)}letbind(){const n=this.emit(),t=this.peek();if(this.consume(),this.expect_whitespace(),h(this.peek())){const i=this.binding();this.expect_whitespace();const o=this.expr();this.expect_whitespace();const r=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:t.id-1,tag:"Nested_Let",binding:i,value:o,body:r}}else throw new Error(`Expected an 'let' to be followed by an identifier but got a ${this.peek().lexeme} instead (token ${this.index} of ${this.tokens.length})`)}iff(){const n=this.emit(),t=this.peek();this.consume(),this.expect_whitespace();const i=this.expr();this.expect_whitespace();const o=this.expr();this.expect_whitespace();const r=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:t.id-1,tag:"Nested_If",condition:i,if_true:o,if_false:r}}call(){const n=this.emit(),t=this.expr();this.expect_whitespace();const i=this.expr();return this.skip_whitespace(),this.expect_closing(),{id:n,token:t.token-1,tag:"Nested_Call",fn:t,arg:i}}binding(){const n=this.emit(),t=this.peek();return this.consume(),{id:n,token:t.id,tag:"Nested_Binding",name:t.value}}skip_whitespace(){for(;!this.is_at_end()&&m(this.peek());)this.consume()}expect_whitespace(){if(this.is_at_end())throw Error(`Parser::expect_whitespace() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(m(this.peek()))this.consume();else throw new Error(`Expected a whitespace and another expression, but got a '${this.peek().lexeme}' instead (token ${this.index} of ${this.tokens.length})`)}expect_closing(){if(this.is_at_end())throw Error(`Parser::expect_closing() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(g(this.peek()))this.consume();else throw new Error(`Expected ')' but got a '${this.peek().lexeme}' instead (token ${this.index} of ${this.tokens.length})`)}}function oe(e){let n=new ie(e);n.skip_whitespace();const t=n.expr();if(n.skip_whitespace(),n.is_at_end())return{ast:t,node_count:n.node_count};throw Error(`Expected a single expression, failed to fully parse input (token ${n.index} of ${n.tokens.length})`)}function k(e,n){return e.tag==="Flat_Literal"}function p(e,n){return e.tag==="Flat_Identifier"}function _(e,n){return e.tag==="Flat_Binding"}function w(e,n){return e.tag==="Flat_Reference"}function E(e,n){return e.tag==="Flat_Lambda"}function y(e,n){return e.tag==="Flat_Let"}function $(e,n){return e.tag==="Flat_If"}function N(e,n){return e.tag==="Flat_Call"}function re(e,n){return e.tag==="Flat_Builtin"}const I=["==","!=","<",">","<=",">=","+","-","*","/","%","~","&&","||","!"];function le(e,n,t,i){if(ae(e))return se(e,n,t,i);if(de(e))return ue(e,n,t,i);throw Error(`The evaluation of the built-in function '${e.name} has not been implemented.`)}function se(e,n,t,i){if(i.length<1)throw Error(`Stack contains ${i.length} arguments, but expected 1 for the unary operation ${e.name}.`);const o=i.pop();if(o===void 0)throw Error(`The argument of ${e.name} is undefined`);if(S(e)){if(typeof o.value!="number")throw Error("Built-in negative operation only supports numbers");return{tag:"Primitive",value:-o.value}}else if(B(e)){if(typeof o.value!="boolean")throw Error("Built-in logical not operation only supports booleans");return{tag:"Primitive",value:!o.value}}else throw Error(`The evaluation of the unary built-in function '${e.name} has not been implemented.`)}function ue(e,n,t,i){if(i.length<2)throw Error(`Stack contains ${i.length} arguments, but expected 2 for the binary operation ${e.name}.`);const o=i.pop(),r=i.pop();if(o===void 0)throw Error(`First argument of ${e.name} is undefined`);if(r===void 0)throw Error(`Second argument of ${e.name} is undefined`);if(P(e))switch(e.name){case"==":return{tag:"Primitive",value:o.value==r.value};case"!=":return{tag:"Primitive",value:o.value!=r.value};default:throw Error(`Cannot evaluate binary operation '${e.name}' at token ${e.token}`)}else if(x(e)||L(e)){if(typeof o.value!="number"||typeof r.value!="number")throw Error("Built-in comparison/arithmetic operations only support numbers");switch(e.name){case"<":return{tag:"Primitive",value:o.value<r.value};case">":return{tag:"Primitive",value:o.value>r.value};case"<=":return{tag:"Primitive",value:o.value<=r.value};case">=":return{tag:"Primitive",value:o.value>=r.value};case"+":return{tag:"Primitive",value:o.value+r.value};case"-":return{tag:"Primitive",value:o.value-r.value};case"*":return{tag:"Primitive",value:o.value*r.value};case"/":return{tag:"Primitive",value:o.value/r.value};case"%":return{tag:"Primitive",value:o.value%r.value};default:throw Error(`Cannot evaluate binary operation '${e.name}' at token ${e.token}`)}}else if(T(e)){if(typeof o.value!="boolean"||typeof r.value!="boolean")throw Error("Built-in logical operations only support booleans");switch(e.name){case"&&":return{tag:"Primitive",value:o.value&&r.value};case"||":return{tag:"Primitive",value:o.value||r.value};default:throw Error(`Cannot evaluate binary operation '${e.name}' at token ${e.token}`)}}throw Error(`The evaluation of the binary built-in function '${e.name} has not been implemented.`)}function ae(e){return B(e)||S(e)}function de(e){return P(e)||x(e)||L(e)||T(e)}function P(e){return e.name==="=="||e.name==="!="}function x(e){return e.name==="<"||e.name===">"||e.name==="<="||e.name===">="}function L(e){return e.name==="+"||e.name==="-"||e.name==="*"||e.name==="/"||e.name==="%"}function S(e){return e.name==="~"}function T(e){return e.name==="&&"||e.name==="||"}function B(e){return e.name==="!"}function ce(){return{parent:void 0,bindings:new Map}}function b(e){return{parent:e,bindings:new Map}}function C(e,n){const t=n.bindings.get(e);if(t!==void 0)return t;if(n.parent!==void 0)return C(e,n.parent);throw new Error(`variable with id ${e} is undefined`)}function u(e,n,t,i){if(k(e))return{tag:"Primitive",value:e.value};if(p(e))throw Error(`Cannot evaluate unresolved reference to '${e.name}' at token ${e.token}`);if(_(e))return C(e.id,t);if(re(e))return le(e,n,t,i);if(w(e))return u(n[e.target.id],n,t,i);if(E(e)){let o=i.pop();if(o!==void 0){let r=b(t);return r.bindings.set(e.binding.id,o),u(n[e.body.id],n,r,i)}else throw new Error("No arguments to bind to variable")}else if(y(e)){let o=b(t);return o.bindings.set(e.binding.id,u(n[e.value.id],n,t,i)),u(n[e.body.id],n,o,i)}else if($(e)){const o=u(n[e.condition.id],n,t,i);if(typeof o.value=="boolean")return u(n[o.value?e.if_true.id:e.if_false.id],n,t,i);throw new Error("Condition in 'if' expression did not evaluate to a boolean value")}else if(N(e)){const o=u(n[e.arg.id],n,t,i);return u(n[e.body.id],n,t,[...i,o])}else throw new Error("unhandled case in evaluation control flow")}function fe(e,n){const t=Array(n);return s(e,t)}function s(e,n){if(Y(e)){const t=e.id,i={id:e.binding.id},o={id:e.body.id};let r={id:t,token:e.token,tag:"Flat_Lambda",binding:i,body:o};n[t]=r,n=s(e.binding,n),n=s(e.body,n)}else if(ee(e)){const t=e.id,i={id:e.binding.id},o={id:e.value.id},r={id:e.body.id};let l={id:t,token:e.token,tag:"Flat_Let",binding:i,value:o,body:r};n[t]=l,n=s(e.binding,n),n=s(e.value,n),n=s(e.body,n)}else if(ne(e)){const t=e.id,i={id:e.condition.id},o={id:e.if_true.id},r={id:e.if_false.id};let l={id:t,token:e.token,tag:"Flat_If",condition:i,if_true:o,if_false:r};n[t]=l,n=s(e.condition,n),n=s(e.if_true,n),n=s(e.if_false,n)}else if(te(e)){const t=e.id,i={id:e.fn.id},o={id:e.arg.id};let r={id:t,token:e.token,tag:"Flat_Call",body:i,arg:o};n[t]=r,n=s(e.fn,n),n=s(e.arg,n)}else if(j(e)||J(e)||Q(e)){const t=e.id;let i={id:t,token:e.token,tag:"Flat_Literal",value:e.value};n[t]=i}else if(V(e)){const t=e.id;let i={id:t,token:e.token,tag:"Flat_Identifier",name:e.name};n[t]=i}else if(X(e)){const t=e.id;let i={id:t,token:e.token,tag:"Flat_Binding",name:e.name};n[t]=i}else throw Error(`Cannot convert nested node of tag '${e.tag}' to a corresponding tag of flat node.`);return n}function he(e){let n=e.map(i=>i),t=be();return a(n[0],n,t)}function a(e,n,t){if(k(e)||_(e)||w(e))return n;if(p(e)){const i=e.id,o=e.token,r=O(e.name,t);if(r==="builtin")if(I.includes(e.name)){const l={id:i,token:o,tag:"Flat_Builtin",name:e.name};n[i]=l}else throw new Error(`'${e.name}' is not a built-in function`);else{const l={id:i,token:o,tag:"Flat_Reference",target:{id:r}};n[i]=l}return n}else if(E(e)){const i=n[e.binding.id],o=n[e.body.id];let r=v(t);return r.bindings.set(i.name,i.id),n=a(o,n,r),n}else if(y(e)){const i=n[e.binding.id],o=n[e.value.id],r=n[e.body.id];let l=v(t);return l.bindings.set(i.name,i.id),n=a(o,n,t),n=a(r,n,l),n}else if(N(e)){const i=n[e.body.id],o=n[e.arg.id];return n=a(i,n,t),n=a(o,n,t),n}else if($(e)){const i=n[e.condition.id],o=n[e.if_true.id],r=n[e.if_false.id];return n=a(i,n,t),n=a(o,n,t),n=a(r,n,t),n}else throw Error(`Name resolution not implemented for node ${e.id} of tag ${e.tag}`)}function O(e,n){if(ge(n)){const t=n.bindings.get(e);if(t!==void 0)return t;throw new Error(`variable with name ${e} is undefined`)}else if(me(n)){const t=n.bindings.get(e);return t!==void 0?t:O(e,n.parent)}else throw Error("Invalid tag of scope. Something is wrong with the name resolution implementation.")}function ge(e){return e.tag==="GlobalScope"}function me(e){return e.tag==="Scope"}function v(e){return{tag:"Scope",parent:e,bindings:new Map}}function be(){let e=new Map;for(let n of I)e.set(n,"builtin");return{tag:"GlobalScope",bindings:e}}function ve(e){const n=R(e),t=oe(n),i=fe(t.ast,t.node_count),o=he(i);let r=ce();return u(o[0],o,r,[]).value}function ke(){const e=document.getElementById("input"),n=document.getElementById("output");n&&new MutationObserver(()=>{n.scrollTop=n.scrollHeight}).observe(n,{childList:!0});const t=e.value;try{const i=ve(t);n.textContent+=`> ${t}
${i}
`}catch(i){const o=i instanceof Error?i.message:String(i);n.textContent+=`> ${t}
${o}
`}}document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("help-btn"),n=document.getElementById("help-box");e==null||e.addEventListener("click",()=>{n&&e&&(n.style.display==="block"?(n.style.display="none",e.textContent="Help"):(n.style.display="block",e.textContent="Close Help"))});const t=document.getElementById("output");t&&(t.textContent=`



















Welcome! Try typing:

((+ 1) 2)

and press Enter. For more info, click on the help button in the top corner.

`);const i=document.getElementById("input");i==null||i.focus(),i==null||i.setSelectionRange(i.value.length,i.value.length),i==null||i.addEventListener("keydown",o=>{o.key==="Enter"&&(o.preventDefault(),ke())})});
