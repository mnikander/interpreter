(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))i(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const l of r.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&i(l)}).observe(document,{childList:!0,subtree:!0});function t(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerPolicy&&(r.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?r.credentials="include":o.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(o){if(o.ep)return;o.ep=!0;const r=t(o);fetch(o.href,r)}})();const T={WHITESPACE:/^\s+/,OPEN:/^\(/,CLOSE:/^\)/,BOOLEAN:/^(true|false)/,NUMBER:/^[-+]?(?:\d*\.\d+|\d+\.\d*|\d+)/,STRING:/^"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,IDENTIFIER:/^(?:([_a-zA-Z][_a-zA-Z0-9]*)|([.,:;!?<>\=\@\#\$\+\-\*\/\%\&\|\^\~]+))/};function C(e){let n={tag:"State",offset:0,line:e,tokens:[]};for(;n.offset<n.line.length;){const t=d(n,"BOOLEAN")??d(n,"NUMBER")??d(n,"STRING")??d(n,"IDENTIFIER")??d(n,"WHITESPACE")??d(n,"OPEN")??d(n,"CLOSE");if(t)t.lexeme==="BOOLEAN"?n=c(n,S(n,t)):t.lexeme==="NUMBER"?n=c(n,F(n,t)):t.lexeme==="STRING"?n=c(n,R(n,t)):t.lexeme==="IDENTIFIER"?n=c(n,A(n,t)):t.lexeme==="OPEN"?n=c(n,M(n)):t.lexeme==="CLOSE"?n=c(n,H(n)):t.lexeme==="WHITESPACE"&&(n=c(n,U(n,t))),n.offset+=t.word.length;else throw Error(`Could not lex '${n.line[n.offset]}'.`)}return n.tokens}function d(e,n){const t=e.line.slice(e.offset),i=T[n].exec(t);if(i)return{lexeme:n,word:i[0]}}function c(e,n){return e.tokens.push(n),e}function S(e,n){const t=n.word!=="false";return{tag:"Token",lexeme:"BOOLEAN",id:e.tokens.length,offset:e.offset,value:t}}function F(e,n){return{tag:"Token",lexeme:"NUMBER",id:e.tokens.length,offset:e.offset,value:Number(n.word)}}function R(e,n){return{tag:"Token",lexeme:"STRING",id:e.tokens.length,offset:e.offset,value:n.word}}function A(e,n){return{tag:"Token",lexeme:"IDENTIFIER",id:e.tokens.length,offset:e.offset,value:n.word}}function M(e,n){return{tag:"Token",lexeme:"OPEN",id:e.tokens.length,offset:e.offset,value:"("}}function H(e,n){return{tag:"Token",lexeme:"CLOSE",id:e.tokens.length,offset:e.offset,value:")"}}function U(e,n){return{tag:"Token",lexeme:"WHITESPACE",id:e.tokens.length,offset:e.offset,value:n.word}}function f(e){return e.tag==="Token"}function D(e){return f(e)&&e.lexeme==="BOOLEAN"}function G(e){return f(e)&&e.lexeme==="NUMBER"}function W(e){return f(e)&&e.lexeme==="STRING"}function h(e){return f(e)&&e.lexeme==="IDENTIFIER"}function p(e){return f(e)&&e.lexeme==="OPEN"}function g(e){return f(e)&&e.lexeme==="CLOSE"}function m(e){return f(e)&&e.lexeme==="WHITESPACE"}function z(e){let n=[],t=0;for(let i=0;i<e.length;i++){const o=e[i];if(p(o))n.push(K(t,o.offset)),t++,n.push(v(t,o.offset)),t++;else if(g(o))n.push(v(t,o.offset)),t++,n.push(j(t,o.offset)),t++;else{let r=o;r.id=t,t++,n.push(r)}}return n}function Z(e){let n=!1;for(let t=0;t<e.length;t++){const i=e[t];if(n)if(m(i))n=!1;else throw Error(`Expected whitespace between tokens '${e[t-1].value}' and '${e[t].value}'.`);else m(i)||(n=!0)}return!0}function q(e){let n=[],t=0;for(let i=0;i<e.length;i++){const o=e[i];if(!m(o)){let r=o;r.id=t,n.push(r),t++}}return n}function v(e,n){return{tag:"Token",lexeme:"WHITESPACE",id:e,offset:n,value:" "}}function K(e,n){return{tag:"Token",lexeme:"OPEN",id:e,offset:n,value:"("}}function j(e,n){return{tag:"Token",lexeme:"CLOSE",id:e,offset:n,value:")"}}function J(e){return e.tag==="Nested_Boolean"}function Q(e){return e.tag==="Nested_Number"}function V(e){return e.tag==="Nested_String"}function X(e){return e.tag==="Nested_Identifier"}function Y(e){return e.tag==="Nested_Binding"}function ee(e){return e.tag==="Nested_Lambda"}function ne(e){return e.tag==="Nested_Let"}function te(e){return e.tag==="Nested_If"}function ie(e){return e.tag==="Nested_Call"}class oe{constructor(n){this.index=0,this.node_count=0,this.tokens=q(n)}peek(){if(0<=this.index&&this.index<this.tokens.length)return this.tokens[this.index];throw Error(`Parser::peek() is out-of-bounds (token ${this.index} of ${this.tokens.length})`)}previous(){if(1<=this.index&&this.index<this.tokens.length+1)return this.tokens[this.index-1];throw Error(`Parser::previous() is out-of-bounds (token ${this.index} of ${this.tokens.length})`)}consume(){this.index++}emit(){const n=this.node_count;return this.node_count++,n}is_at_end(){return this.index===this.tokens.length}expr(){if(this.is_at_end())throw Error(`Parser::expr() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(D(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_Boolean",value:this.previous().value};if(G(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_Number",value:this.previous().value};if(W(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_String",value:this.previous().value};if(h(this.peek()))return this.consume(),{id:this.emit(),token:this.index-1,tag:"Nested_Identifier",name:this.previous().value};if(p(this.peek())){this.consume();const n=this.peek();return h(n)&&n.value==="lambda"?this.lambda():h(n)&&n.value==="let"?this.letbind():h(n)&&n.value==="if"?this.iff():this.call()}else throw g(this.peek())?Error(`Expected an expression but got ')' instead (token ${this.index} of ${this.tokens.length})`):Error(`Unknown token tag '${this.peek()}' (token ${this.index} of ${this.tokens.length})`)}lambda(){const n=this.emit(),t=this.peek();if(this.consume(),h(this.peek())){const i=this.binding(),o=this.expr();return this.expect_closing(),{id:n,token:t.id-1,tag:"Nested_Lambda",binding:i,body:o}}else throw new Error(`Expected an 'lambda' to be followed by an identifier but got a ${this.peek().lexeme} instead (token ${this.index} of ${this.tokens.length})`)}letbind(){const n=this.emit(),t=this.peek();if(this.consume(),h(this.peek())){const i=this.binding(),o=this.expr(),r=this.expr();return this.expect_closing(),{id:n,token:t.id-1,tag:"Nested_Let",binding:i,value:o,body:r}}else throw new Error(`Expected an 'let' to be followed by an identifier but got a ${this.peek().lexeme} instead (token ${this.index} of ${this.tokens.length})`)}iff(){const n=this.emit(),t=this.peek();this.consume();const i=this.expr(),o=this.expr(),r=this.expr();return this.expect_closing(),{id:n,token:t.id-1,tag:"Nested_If",condition:i,then_branch:o,else_branch:r}}call(){const n=this.emit(),t=this.expr(),i=this.expr();return this.expect_closing(),{id:n,token:t.token-1,tag:"Nested_Call",fn:t,arg:i}}binding(){const n=this.emit(),t=this.peek();return this.consume(),{id:n,token:t.id,tag:"Nested_Binding",name:t.value}}expect_closing(){if(this.is_at_end())throw Error(`Parser::expect_closing() is out-of-bounds (token ${this.index} of ${this.tokens.length})`);if(g(this.peek()))this.consume();else throw new Error(`Expected ')' but got a '${this.peek().lexeme}' instead (token ${this.index} of ${this.tokens.length})`)}}function re(e){let n=new oe(e);const t=n.expr();if(n.is_at_end())return{ast:t,node_count:n.node_count};throw Error(`Expected a single expression, failed to fully parse input (token ${n.index} of ${n.tokens.length})`)}const _=["==","!=","<",">","<=",">=","+","-","*","/","%","~","&&","||","!"];function E(e,n){return e.tag==="Flat_Literal"}function y(e,n){return e.tag==="Flat_Identifier"}function w(e,n){return e.tag==="Flat_Binding"}function $(e,n){return e.tag==="Flat_Reference"}function N(e,n){return e.tag==="Flat_Lambda"}function x(e,n){return e.tag==="Flat_Let"}function I(e,n){return e.tag==="Flat_If"}function B(e,n){return e.tag==="Flat_Call"}function le(e,n){return e.tag==="Flat_Builtin"}function ue(){return{parent:void 0,bindings:new Map}}function P(e){return{parent:e,bindings:new Map}}function L(e,n){const t=n.bindings.get(e);if(t!==void 0)return t;if(n.parent!==void 0)return L(e,n.parent);throw new Error(`variable with id ${e} is undefined`)}function a(e,n,t){if(E(e))return{tag:"Primitive",value:e.value};if(y(e))throw Error(`Cannot evaluate unresolved reference to '${e.name}' at token ${e.token}`);if(w(e))return L(e.id,t);if($(e))return a(n[e.target.id],n,t);if(le(e))return ce(e);if(N(e))return{tag:"Closure",binding:e.binding,body:e.body,env:t};if(x(e)){let i=P(t);return i.bindings.set(e.binding.id,a(n[e.value.id],n,t)),a(n[e.body.id],n,i)}else if(I(e)){const i=a(n[e.condition.id],n,t);if(b(i)&&typeof i.value=="boolean")return a(n[i.value?e.then_branch.id:e.else_branch.id],n,t);throw new Error(`Expect condition in 'if' expression to evaluate to a boolean value, evaluated to ${i.tag} instead`)}else if(B(e)){const i=a(n[e.body.id],n,t),o=a(n[e.arg.id],n,t);return se(i,o,n)}else throw new Error("unhandled case in evaluation control flow")}function se(e,n,t){if(ae(e)){let i=P(e.env);return i.bindings.set(e.binding.id,n),a(t[e.body.id],t,i)}else if(de(e)){if(b(n))return e.args.push(n),e.args.length==e.arity?e.impl(e.args):e;throw Error(`Tried calling builtin function '${e.name}' with non-primitive argument of type '${n.tag}'`)}else throw`Attempted to call a non-function value ${e.value} of type ${e.tag}`}function b(e){return e.tag==="Primitive"}function ae(e){return e.tag==="Closure"}function de(e){return e.tag==="Builtin"}function ce(e,n){switch(e.name){case"~":return{tag:"Builtin",name:e.name,arity:1,impl:t=>({tag:"Primitive",value:-t[0].value}),args:[]};case"!":return{tag:"Builtin",name:e.name,arity:1,impl:t=>({tag:"Primitive",value:!t[0].value}),args:[]};case"==":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value==t[1].value}),args:[]};case"!=":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value!=t[1].value}),args:[]};case"<":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value<t[1].value}),args:[]};case">":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value>t[1].value}),args:[]};case"<=":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value<=t[1].value}),args:[]};case">=":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value>=t[1].value}),args:[]};case"+":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value+t[1].value}),args:[]};case"-":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value-t[1].value}),args:[]};case"*":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value*t[1].value}),args:[]};case"/":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value/t[1].value}),args:[]};case"%":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value%t[1].value}),args:[]};case"&&":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value&&t[1].value}),args:[]};case"||":return{tag:"Builtin",name:e.name,arity:2,impl:t=>({tag:"Primitive",value:t[0].value||t[1].value}),args:[]}}}function fe(e,n){const t=Array(n);return u(e,t)}function u(e,n){if(ee(e)){const t=e.id,i={id:e.binding.id},o={id:e.body.id};let r={id:t,token:e.token,tag:"Flat_Lambda",binding:i,body:o};n[t]=r,n=u(e.binding,n),n=u(e.body,n)}else if(ne(e)){const t=e.id,i={id:e.binding.id},o={id:e.value.id},r={id:e.body.id};let l={id:t,token:e.token,tag:"Flat_Let",binding:i,value:o,body:r};n[t]=l,n=u(e.binding,n),n=u(e.value,n),n=u(e.body,n)}else if(te(e)){const t=e.id,i={id:e.condition.id},o={id:e.then_branch.id},r={id:e.else_branch.id};let l={id:t,token:e.token,tag:"Flat_If",condition:i,then_branch:o,else_branch:r};n[t]=l,n=u(e.condition,n),n=u(e.then_branch,n),n=u(e.else_branch,n)}else if(ie(e)){const t=e.id,i={id:e.fn.id},o={id:e.arg.id};let r={id:t,token:e.token,tag:"Flat_Call",body:i,arg:o};n[t]=r,n=u(e.fn,n),n=u(e.arg,n)}else if(J(e)||Q(e)||V(e)){const t=e.id;let i={id:t,token:e.token,tag:"Flat_Literal",value:e.value};n[t]=i}else if(X(e)){const t=e.id;let i={id:t,token:e.token,tag:"Flat_Identifier",name:e.name};n[t]=i}else if(Y(e)){const t=e.id;let i={id:t,token:e.token,tag:"Flat_Binding",name:e.name};n[t]=i}else throw Error(`Cannot convert nested node of tag '${e.tag}' to a corresponding tag of flat node.`);return n}function he(e){let n=e.map(i=>i),t=be();return s(n[0],n,t)}function s(e,n,t){if(E(e)||w(e)||$(e))return n;if(y(e)){const i=e.id,o=e.token,r=O(e.name,t);if(r==="builtin")if(_.includes(e.name)){const l={id:i,token:o,tag:"Flat_Builtin",name:e.name};n[i]=l}else throw new Error(`'${e.name}' is not a built-in function`);else{const l={id:i,token:o,tag:"Flat_Reference",target:{id:r}};n[i]=l}return n}else if(N(e)){const i=n[e.binding.id],o=n[e.body.id];let r=k(t);return r.bindings.set(i.name,i.id),n=s(o,n,r),n}else if(x(e)){const i=n[e.binding.id],o=n[e.value.id],r=n[e.body.id];let l=k(t);return l.bindings.set(i.name,i.id),n=s(o,n,t),n=s(r,n,l),n}else if(B(e)){const i=n[e.body.id],o=n[e.arg.id];return n=s(i,n,t),n=s(o,n,t),n}else if(I(e)){const i=n[e.condition.id],o=n[e.then_branch.id],r=n[e.else_branch.id];return n=s(i,n,t),n=s(o,n,t),n=s(r,n,t),n}else throw Error(`Name resolution not implemented for node ${e.id} of tag ${e.tag}`)}function O(e,n){if(ge(n)){const t=n.bindings.get(e);if(t!==void 0)return t;throw new Error(`variable with name ${e} is undefined`)}else if(me(n)){const t=n.bindings.get(e);return t!==void 0?t:O(e,n.parent)}else throw Error("Invalid tag of scope. Something is wrong with the name resolution implementation.")}function ge(e){return e.tag==="GlobalScope"}function me(e){return e.tag==="Scope"}function k(e){return{tag:"Scope",parent:e,bindings:new Map}}function be(){let e=new Map;for(let n of _)e.set(n,"builtin");return{tag:"GlobalScope",bindings:e}}function ve(e){let n=0;for(let t=0;t<e.length;t++)if(e[t]=="("?n++:e[t]==")"&&n--,n<0)throw Error(`Unbalanced parentheses. Unexpected ')' at character ${t}. Perhaps it should not be there, or a '(' is missing before it.`);if(n!=0)throw Error(`Unbalanced parentheses. Expected ${n} more ')'.`);return!0}function ke(e){ve(e);const n=C(e);Z(z(n));const t=re(n),i=fe(t.ast,t.node_count),o=he(i);let r=ue();const l=a(o[0],o,r);if(b(l))return l.value;throw Error(`Interpreter expected a boolean, number, or string result, but got a '${l.tag}' instead.`)}function pe(){const e=document.getElementById("input"),n=document.getElementById("output");n&&new MutationObserver(()=>{n.scrollTop=n.scrollHeight}).observe(n,{childList:!0});const t=e.value;try{const i=ke(t);n.textContent+=`> ${t}
${i}
`}catch(i){const o=i instanceof Error?i.message:String(i);n.textContent+=`> ${t}
${o}
`}}document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("help-btn"),n=document.getElementById("help-box");e==null||e.addEventListener("click",()=>{n&&e&&(n.style.display==="block"?(n.style.display="none",e.textContent="Help"):(n.style.display="block",e.textContent="Close Help"))});const t=document.getElementById("output");t&&(t.textContent=`



















Welcome! Try typing:

((+ 1) 2)

and press Enter.

For more info, click on the 'Help'
button in the top-left corner.

`);const i=document.getElementById("input");i==null||i.focus(),i==null||i.setSelectionRange(i.value.length,i.value.length),i==null||i.addEventListener("keydown",o=>{o.key==="Enter"&&(o.preventDefault(),pe())})});
